// SPDX-License-Identifier: MIT

//        ✦     *        .         ✶         *        .       ✦       .
//  ✦   _______..___________.    ___      .______        _______      ___   .___________. _______   ✦
//     /       ||           |   /   \     |   _  \      /  _____|    /   \  |           ||   ____|  *
//    |   (----``---|  |----`  /  ^  \    |  |_)  |    |  |  __     /  ^  \ `---|  |----`|  |__      .
//     \   \        |  |      /  /_\  \   |      /     |  | |_ |   /  /_\  \    |  |     |   __|     ✶
// .----)   |       |  |     /  _____  \  |  |\  \----.|  |__| |  /  _____  \   |  |     |  |____   *
// |_______/        |__|    /__/     \__\ | _| `._____| \______| /__/     \__\  |__|     |_______|  ✦
//         *       .      ✦      *      .        ✶       *      ✦       .       *        ✶

pragma solidity 0.8.20;

import {DataTypes} from "./DataTypes.sol";
import {Token} from "./Token.sol";
import {Clock} from "./Clock.sol";
import {Errors} from "./Errors.sol";
import {IStargateNFT} from "../../interfaces/IStargateNFT.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

/// @title VetGeneratedVtho
/// @notice VeChain has a dual-token economic model where VET holders automatically generate VTHO over time.
/// The generation rate is 0.000432 VTHO per VET per day, or 5×10^-9 VTHO per VET per second.
/// This library contains the logic for claiming the VTHO rewards generated by staked VET.
library VetGeneratedVtho {
    using SafeERC20 for IERC20;

    // ------------------ Events ------------------ //

    /// @notice Emitted when VTHO rewards are claimed for a token
    /// @param owner The address that claimed the rewards
    /// @param tokenId The ID of the token for which rewards were claimed
    /// @param amount The amount of VTHO rewards claimed
    event BaseVTHORewardsClaimed(address indexed owner, uint256 indexed tokenId, uint256 amount);

    // ------------------ Setters ------------------ //
    /// @notice Claim VTHO rewards for a token
    /// @dev Everyone can trigger this function, no authorization checks are performed
    /// @param $ Storage pointer
    /// @param _tokenId The ID of the token to claim rewards for
    function claimRewards(DataTypes.StargateNFTStorage storage $, uint256 _tokenId) external {
        _claimRewards($, _tokenId);
    }

    /// @notice Claim VTHO rewards for a token
    /// @dev Everyone can trigger this function, no authorization checks are performed
    /// @param $ Storage pointer
    /// @param _tokenId The ID of the token to claim rewards for
    function _claimRewards(DataTypes.StargateNFTStorage storage $, uint256 _tokenId) internal {
        DataTypes.Token storage token = $.tokens[_tokenId];

        // Validate token exists
        if (token.levelId == 0) {
            revert Errors.TokenDoesNotExist(_tokenId);
        }

        // If this field is not set, the token is not staking VET
        if (token.lastVthoClaimTimestamp == 0) {
            revert Errors.NotStakingVet(_tokenId);
        }

        uint256 rewardsToClaim = _claimableRewards($, _tokenId);
        if (rewardsToClaim == 0) {
            revert Errors.NoBaseVthoRewardsToClaim(_tokenId);
        }

        // Check if contract has enough VTHO
        uint256 contractBalance = IERC20($.vthoToken).balanceOf(address(this));
        if (contractBalance < rewardsToClaim) {
            revert Errors.InsufficientContractBalance(contractBalance, rewardsToClaim);
        }

        // Update last claim timestamp
        token.lastVthoClaimTimestamp = Clock._timestamp();

        address owner = IStargateNFT(address(this)).ownerOf(_tokenId);

        emit BaseVTHORewardsClaimed(owner, _tokenId, rewardsToClaim);

        // Transfer rewards to the caller and revert if it fails
        $.vthoToken.safeTransfer(owner, rewardsToClaim);
    }

    // ------------------ Getters ------------------ //

    /// @notice Calculate the amount of VTHO rewards available for a token
    /// @param $ Storage pointer
    /// @param _tokenId The ID of the token to calculate rewards for
    /// @return amount The amount of VTHO rewards available
    function claimableRewards(
        DataTypes.StargateNFTStorage storage $,
        uint256 _tokenId
    ) external view returns (uint256) {
        return _claimableRewards($, _tokenId);
    }

    /// @notice Calculate the amount of VTHO rewards available for a token
    /// @param $ Storage pointer
    /// @param _tokenId The ID of the token to calculate rewards for
    /// @return amount The amount of VTHO rewards available
    function _claimableRewards(
        DataTypes.StargateNFTStorage storage $,
        uint256 _tokenId
    ) internal view returns (uint256) {
        DataTypes.Token memory token = $.tokens[_tokenId];

        if (token.lastVthoClaimTimestamp == 0) {
            return 0;
        }

        uint48 currentTimestamp = Clock._timestamp();

        // If reward generation has ended, use the end timestamp instead of current time
        uint48 vthoGenerationEndTimestamp = $.vthoGenerationEndTimestamp;
        if (vthoGenerationEndTimestamp != 0 && currentTimestamp > vthoGenerationEndTimestamp) {
            currentTimestamp = vthoGenerationEndTimestamp;
        }

        return calculateVTHO(token.lastVthoClaimTimestamp, currentTimestamp, token.vetAmountStaked);
    }

    /// @notice This function calculates the VTHO generated between two timestamps for
    /// a given amount of VET. The formula follows the official VTHO generation rate:
    /// VTHO = VET × 5×10^-9 × time_in_seconds.
    /// @param _t1 Time in seconds
    /// @param _t2 Time in seconds
    /// @param _vetAmount VET in wei
    /// @return vtho generated in wei
    function calculateVTHO(
        uint48 _t1,
        uint48 _t2,
        uint256 _vetAmount
    ) public pure returns (uint256 vtho) {
        if (_t1 > _t2) {
            return 0;
        }

        return ((_vetAmount * 5) * (_t2 - _t1)) / (10 ** 9);
    }
}
